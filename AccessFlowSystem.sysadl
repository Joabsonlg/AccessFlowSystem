Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } enum OrderStatus { Pending , Prepared , Completed , Cancelled } enum AccessStatus { EntryAllowed , EntryDenied , ExitAllowed , ExitDenied } value type DateTime { } value type ProductCode { } value type TicketCode { } } Requirement TicketIssuanceFR ( 1 ) { text = "O sistema deve permitir ao usuário solicitar e receber um ticket com código QR para acesso e transações." derive SystemAccessControlFR , BeveragePurchaseFR , ReadySnackPurchaseFR , OnDemandSnackOrderingFR , PaymentProcessingFR ; } Requirement SystemAccessControlFR ( 2 ) { text = "O sistema deve validar os tickets na entrada e saída usando catracas eletrônicas controladas." } Requirement BeveragePurchaseFR ( 3 ) { text = "O sistema deve permitir a compra de bebidas por máquinas automáticas usando o ticket." } Requirement ReadySnackPurchaseFR ( 4 ) { text = "O sistema deve permitir a compra de lanches prontos através de máquinas automáticas utilizando o ticket." } Requirement OnDemandSnackOrderingFR ( 5 ) { text = "O sistema deve permitir o pedido de lanches feitos sob demanda através de terminais de pedido." derive SnackPickupFR ; } Requirement SnackPickupFR ( 6 ) { text = "O sistema deve permitir a retirada de lanches sob demanda em pontos de coleta específicos." } Requirement PaymentProcessingFR ( 7 ) { text = "O sistema deve processar os pagamentos de forma eletrônica, garantindo a verificação no término da visita." } Requirement PerformanceNFR ( 8 ) { text = "O sistema deve garantir um tempo de resposta rápido nas transações e no controle de acesso." } Requirement AvailabilityNFR ( 9 ) { text = "O sistema deve estar disponível 24 por dia 7 dias por semana, exceto por eventuais manutenções." } Requirement UsabilityNFR ( 10 ) { text = "O sistema deve oferecer interfaces intuitivas para a interação com os usuários." } Requirement MaintainabilityNFR ( 11 ) { text = "O sistema deve ser fácil de manter e atualizar, com suporte para mudanças rápidas e eficientes." } Requirement ScalabilityR ( 12 ) { text = "O sistema deve ser capaz de escalar para suportar um aumento de clientes e transações." } package AFSConnectors { import AFSPorts ; } package AFSComponents { import AFSPorts ; import SysADL.types ; import AFSConnectors ;
	component def AccessFlowSystem { configuration { components : EntryTurnstile : EntryTurnstile { using ports : ticketDataP : TicketValidationIn ; entryAccessP : AccessStatusOut ; } ControlSystem : ControlSystem ; ExitTurnstile : ExitTurnstile { using ports : ticketReadExitP : TicketReadIn ; exitAccessP : AccessStatusOut ; } MenuSystem : MenuSystem ; TicketIssuingMachine : TicketIssuingMachine { using ports : ticketRequestP : TicketRequestIn ; ticketIssuedP : TicketIssuedOut ; } PaymentTerminal : PaymentTerminal { using ports : transactionResultP : TransactionResultOut ; ticketReadPaymentP : TicketReadIn ; } BeverageVendingMachines : BeverageVendingMachines { using ports : beverageSelectionP : BeverageSelectionIn ; beveragePickupP : BeveragePickupOut ; ticketReadBeverageVendingMachineP : TicketReadIn ; } ReadySnackVendingMachines : ReadySnackVendingMachines { using ports : snackSelectionP : SnackSelectionIn ; snackPickupP : SnackPickupOut ; ticketReadReadySnackVendingMachingP : TicketReadIn ; } OnDemandSnackOrderingTerminal : OnDemandSnackOrderingTerminal { using ports : onDemandSnackOrderP : SnackOrderIn ; onDemandSnackOrderStatusP : OrderStatusOut ; ticketReadOnDemandSnackOrderP : TicketReadIn ; } OrderedSnackPickupPoint : OrderedSnackPickupPoint { using ports : pickupRequestP : PickupRequestIn ; pickupValidationP : PickupValidationOut ; ticketReadOrderedSnackPickupPointP : TicketReadIn ; } } }
	component def EntryTurnstile { ports : ticketDataP : TicketValidationIn ; entryAccessP : AccessStatusOut ; }
	component def ExitTurnstile { ports : ticketReadExitP : TicketReadIn ; exitAccessP : AccessStatusOut ; }
	component def TicketIssuingMachine { ports : ticketRequestP : TicketRequestIn ; ticketIssuedP : TicketIssuedOut ; }
	component def BeverageVendingMachines { ports : beverageSelectionP : BeverageSelectionIn ; beveragePickupP : BeveragePickupOut ; ticketReadBeverageVendingMachineP : TicketReadIn ; }
	component def ReadySnackVendingMachines { ports : snackSelectionP : SnackSelectionIn ; snackPickupP : SnackPickupOut ; ticketReadReadySnackVendingMachingP : TicketReadIn ; }
	component def OnDemandSnackOrderingTerminal { ports : onDemandSnackOrderP : SnackOrderIn ; onDemandSnackOrderStatusP : OrderStatusOut ; ticketReadOnDemandSnackOrderP : TicketReadIn ; }
	component def OrderedSnackPickupPoint { ports : pickupRequestP : PickupRequestIn ; pickupValidationP : PickupValidationOut ; ticketReadOrderedSnackPickupPointP : TicketReadIn ; }
	component def PaymentTerminal { ports : transactionResultP : TransactionResultOut ; ticketReadPaymentP : TicketReadIn ; } boundary
	component def ControlSystem { } boundary
	component def MenuSystem { } } package AFSPorts { import SysADL.types ; port def TicketValidationIn { flow in String } port def AccessStatusOut { flow out AccessStatus } port def TicketRequestIn { flow in Boolean } port def TicketIssuedOut { flow out String } port def BeverageSelectionIn { flow in ProductCode } port def TransactionResultOut { flow out Boolean } port def SnackSelectionIn { flow in ProductCode } port def SnackOrderIn { flow in ProductCode } port def OrderStatusOut { flow out OrderStatus } port def PickupRequestIn { flow in String } port def SnackPickupOut { flow out Boolean } port def TicketReadIn { flow in TicketCode } port def BeveragePickupOut { flow out Boolean } port def PickupValidationOut { flow out Boolean } } Requirement SecurityNFR ( 13 ) { text = "O sistema deve garantir a segurança dos dados de transação e acesso dos usuários" }